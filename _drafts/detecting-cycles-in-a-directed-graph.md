---
title: "Topological sorts"
categories: algorithms graph-theory
---

Detecting and finding cycles in directed graphs are common problems in graph theory. A while back I was looking for an algorithm to detect whether a graph had a cycle or not, and it turns out there are a lot of different ways to approach this. Ultimately, the best method to use will probably depend on why you're looking for cycles, and what you want to do with them (or their absence).

In my case, I was looking for something that I later learned is called a topological sort. A topological sort is an ordering of the vertices in a graph, such that for any directed edge from vertex $$u$$ to $$v$$, $$u$$ comes before $$v$$ in the ordering. Obviously, there may be many such orderings (consider the orderings possible on two vertices with no path between them). However, if the graph has one or more cycles, no such ordering exists. If it did, every vertex in the cycle would necessarily come before all the other vertices in the cycle, which is impossible.

Finding a valid topological sort is therefore equivalent to determining whether or not a directed graph has a cycle. It's also pretty intuitive that a process looking for cycles might keep a topological sort of visited vertices during its search.

A quick look on [wikipedia](https://en.wikipedia.org/wiki/Topological_sorting) reveals two algorithms to find a topological sort, both with linear running times. One is a slightly modified depth first search, while the other, Kahn's algorithm, is new to me. Which one is faster in practice? Let's find out.

We'll make some simple graph and node (representing vertices) classes in Java for our benchmarks, using the adjacency list representation. Random graphs of $$N$$ nodes will be generated by setting edges with a certain probability, which determines how sparse the resulting graph will be.

```java
class Graph {
  Node[] nodes;
}

class Node {
  Node[] children;
}
```

## Depth first search

Regular DFS works by marking each node visited during the search, and exploring paths as far as possible before backtracking. While this approach is perfectly capable of detecting cycles, it will also give false positives. Consider the following two graphs.

The first graph has a loop, but it is not a cycle. There is no path that begins and ends at a single node. The second graph has an obvious cycle, which can be characterized by the path $$p = a \to b \to c \to a$$. Applying DFS to the second graph, the algorithm will follow $$p$$. When it gets to $$a$$ the second time, it will discover that it has already been visited, and correctly conclude that a cycle exists. No matter where DFS begins, it will detect the cycle.

What happens when DFS searches the first graph? Suppose we follow the first part of $$p$$ again, visiting $$a$$, $$b$$, and then $$c$$. At this point, there are no more outgoing edges, so $$c$$ is popped from the search stack, leaving us at $$b$$. No more outgoing edges are available here, either, so $$b$$ is popped and we are back at $$a$$. The algorithm then visits $$d$$, and discovers an edge to $$c$$, which is marked visited. It may then incorrectly conclude that there exists a cycle.

What's the difference between these two cases, and how can we modify DFS to only find actual cycles? In the search on the first graph, we visited $$c$$ for the second time only *after* it had been popped off the search stack. In the search of the second graph, you will notice that $$a$$ was still in the search stack when the edge $$c \to a$$ was traversed. This will be the case independent of where DFS begins. Making this distinction will identify cycles in every time.

In graph theory terms, $$c \to a$$ is called a **back edge**, since $$a$$ has already been visited, and is an ancestor of $$c$$. For the first graph, $$d \to c$$ is called a **cross edge** since $$c$$ has already been visited, but it is neither an ancestor or descendent of $$d$$. Other possibilities are **forward edges** (the node being visited for the second time is a descendent of the first node) and a **tree edge** (the node has not yet been visited). Only a back edge indicates the presence of a cycle. Note that this terminology only applies in the context of a specific search, i.e. starting at $$a$$. If DFS were to start elsewhere, the edges may receive different terms.

Let's implement our modified DFS. We will need to extend the `Node` class to include two boolean flags: `visited`, and `inStack`.

```java
List<Node> topologicalSortDFS(Graph g) {
  LinkedList<Node> sortedNodes = new LinkedList<Node>;

  for (Node n : g.nodes) {
    if (!n.visited) {
      visit(sortedNotes, n);
    }
  }
  return sortedNodes;
}

void visit(LinkedList<Node> sortedNodes, Node n) {
  if (n.inStack) throw new CyclicGraphException();

  n.inStack = true;
  for (Node m : n.children) {
    if (!m.visited) {
      visit(m);
    }
  }
  n.visited = true;
  n.inStack = false;
  sortedNodes.addFirst(n);
}
```

## Kahn's algorithm

While the modified DFS builds the topological sort starting with the nodes that must be ordered last, Kahn's algorithm visits nodes in the same order as the eventual sort.

The algorithm starts with a set of nodes that have no incoming edges. These nodes can be placed at the beginning of the sorted list without any issues. Once a node is added to the list, the algorithm removes all edges beginning from this node, potentially creating new nodes that now have no incoming edges. It keeps placing nodes in the sorted list until there are no more nodes left, or there are no more nodes without any incoming edges. The latter case indicates a cycle, since a graph where every node has at least one incoming edge necessarily contains a cycle.

Our current graph structure does not easily allow us to find nodes without incoming edges. In the interest of comparing the two algorithms fairly, we will assume this information is available a priori since it depends on the way that the graph is stored. We will therefore assume the `Node` class instead has a hashset of parent nodes. The use of a hashset will allow the algorithm to efficiently remove edges.

```java
class Node {
  Node[] children;
  Set<Node> parents;
}
```

Let's implement the algorithm, using the new `Node` class.

```java
List<Node> topologicalSortKahn(Graph g) {
  LinkedList<Node> sortedNodes = new LinkedList<Node>;
  Queue<Node> freeNodes = getFreeNodes(g);

  while (freeNodes.size() > 0) {
    Node n = freeNodes.remove();
    sortedNodes.addLast(n);
    removeEdges(freeNodes, n);
  }

  if (sortedNodes.size() != g.nodes.length) throw new CyclicGraphException();

  return sortedNodes;
}

void removeEdges(Queue<Node> freeNodes, Node parent) {
  for (Node n : parent.children) {
    n.parents.remove(parent);
    if (n.parents.isEmpty()) {
      freeNodes.add(n);
    }
  }
}

Queue<Node> getFreeNodes(Graph g) {
  Queue<Node> freeNodes = new LinkedList<Node>;
  for (Node n : g.nodes) {
    if (n.parents.isEmpty()) {
      freeNodes.add(n);
    }
  }
}
```

## Benchmarks
