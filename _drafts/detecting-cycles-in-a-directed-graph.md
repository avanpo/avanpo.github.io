---
title: "Detecting cycles in a directed graph"
categories: algorithms graph-theory
---

Detecting and finding cycles in directed graphs are common problems in graph theory. A while back I was looking for an algorithm to detect whether a graph had a cycle or not, and it turns out there are a lot of different ways to approach this. Ultimately, the best method to use will probably depend on why you're looking for cycles, and what you want to do with them (or their absence).

In my case, I was looking for something that I later learned is called a topological sort. A topological sort is an ordering of the vertices in a graph, such that for any directed edge from vertex $$u$$ to $$v$$, $$u$$ comes before $$v$$ in the ordering. Obviously, there may be many such orderings (consider the orderings possible on two vertices with no path between them). However, if the graph has one or more cycles, no such ordering exists. If it did, every vertex in the cycle would necessarily come before all the other vertices in the cycle, which is impossible.

Finding a valid topological sort is therefore equivalent to determining whether or not a directed graph has a cycle. It's also pretty intuitive that a process looking for cycles might keep a topological sort of visited vertices during its search.

A quick look on [wikipedia](https://en.wikipedia.org/wiki/Topological_sorting) reveals two algorithms to find a topological sort, both with linear running times. One is a slightly modified depth first search, while the other, Kahn's algorithm, is new to me. Which one is faster in practice? Let's find out.

We'll make some simple graph and node classes in Java for our test, using the adjacency list representation. Random graphs of $$N$$ nodes will be generated by setting edges with a certain probability, which determines how sparse the resulting graph will be.

```java
class Graph {
  Node[] nodes;
}

class Node {
  int val;
  Node[] neighbors;
}
```

## Depth first search

Regular DFS works by marking each node visited during the search, and exploring paths as far as possible before backtracking. While this approach is perfectly capable of detecting cycles, it will also give false positives. Consider the following two graphs.

The first graph has a loop, but it is not a cycle. There is no path that begins and ends at a single node. The second graph has an obvious cycle, which can be characterized by the path $$p = a \to b \to c \to a$$. Applying DFS to the second graph, the algorithm will follow $$p$$. When it gets to $$a$$ the second time, it will discover that it has already been visited, and correctly conclude that a cycle exists. No matter where DFS begins, it will detect the cycle.

What happens when DFS searches the first graph? Suppose we follow the first part of $$p$$ again, visiting $$a$$, $$b$$, and then $$c$$. At this point, there are no more outgoing edges, so $$c$$ is popped from the search stack, leaving us at $$b$$. No more outgoing edges are available here, either, so $$b$$ is popped and we are back at $$a$$. The algorithm then visits $$d$$, and discovers an edge to $$c$$, which is marked visited. It may then incorrectly conclude that there exists a cycle.

What's the difference between these two cases, and how can we modify DFS to only find actual cycles? In the search on the first graph, we visited $$c$$ for the second time only *after* it had been popped off the search stack. In the search of the second graph, you will notice that $$a$$ was still in the search stack when the edge $$c \to a$$ was traversed. This will be the case independent of where DFS begins. Making this distinction will identify cycles in every time.

In graph theory terms, $$c \to a$$ is called a **back edge**, since $$a$$ has already been visited, and is an ancestor of $$c$$. For the first graph, $$d \to c$$ is called a **cross edge** since $$c$$ has already been visited, but it is neither an ancestor or descendent of $$d$$. Other possibilities are **forward edges** (the node being visited for the second time is a descendent of the first node) and a **tree edge** (the node has not yet been visited). Only a back edge indicates the presence of a cycle. Note that this terminology only applies in the context of a specific search, i.e. starting at $$a$$. If DFS were to start elsewhere, the edges may receive different terms.

Let's implement our modified DFS.

```java

